# Ralph

**The Programming Force Multiplier That Fits in Your Pocket**

Ralph is the AI-powered development companion that transforms ordinary programmers into coding superhumans. Built as a single portable binary that runs anywhere, Ralph doesn't just chat about code - it writes it, fixes it, explains it, and ships it. This is the tool that turns 1x programmers into 10x programmers, and 10x programmers into unstoppable 100x forces of nature.

## The Developer's Secret Weapon

Imagine having a senior developer, systems architect, and research assistant all rolled into one - available 24/7, never gets tired, never judges your code, and costs pennies to run. That's Ralph.

### üöÄ **Code Creation That Actually Works**
Ralph doesn't just generate boilerplate - it crafts production-ready solutions tailored to your exact needs. From complex algorithms to entire application architectures, Ralph understands context, follows your coding style, and delivers code that actually compiles and runs.

### üîç **Internet-Powered Research Engine**
Stuck on an obscure API? Need to understand a new framework? Ralph can research the latest documentation, browse GitHub repos, analyze StackOverflow discussions, and synthesize the information into actionable insights - all while you grab coffee.

### üìÑ **Document Processing Superpowers**
Ralph doesn't just read code - it devours PDF documentation, technical specs, and research papers. Drop a 500-page API manual on Ralph, and it instantly indexes every function, stores semantic relationships, and answers questions about edge cases buried on page 347. Your entire technical library becomes instantly searchable and conversational.

### üß† **MCP Protocol Integration**
Ralph automatically connects to MCP-enabled tools and services when it needs them to complete your tasks. Ask Ralph to deploy to AWS, and it seamlessly uses AWS MCP tools behind the scenes. Need database optimization? Ralph automatically connects to your database through MCP. Your entire development ecosystem becomes Ralph's invisible superpower.

### ü§ù **Your AI Pair Programming Partner**
Ralph reviews your code with the precision of a senior architect, catches bugs before they hit production, suggests optimizations you never considered, and explains complex codebases like a patient mentor. It's the pair programmer who makes you better, not just faster.

### ‚ö° **Automation-First Architecture**
One-shot mode means Ralph integrates seamlessly into CI/CD pipelines, git hooks, and automated workflows. Build scripts that fix themselves. Tests that write documentation. Code reviews that happen in milliseconds, not hours.

## The Interactive Development Experience

The real power of Ralph isn't in one-shot commands - it's in the **conversational development workflow** where you and Ralph build, iterate, and perfect code together in real-time.

```bash
$ ./ralph
Ralph Interactive Mode
Type 'quit' or 'exit' to end the conversation.

> I want to build a REST API for a todo app in Python, but I'm not sure where to start

[Ralph provides architecture overview and asks clarifying questions]

> Let's use FastAPI. Create the basic project structure

[Ralph creates files, explains choices, shows next steps]

> Now add a User model with authentication

[Ralph implements user model, database setup, auth middleware]

> The password hashing isn't working. Here's the error...

[Ralph debugs, fixes the issue, explains the problem]

> Add rate limiting to prevent abuse

[Ralph implements rate limiting, adds configuration, updates docs]

> Write comprehensive tests for everything we've built

[Ralph creates test suite, explains testing strategy]

> How do I deploy this to production?

[Ralph provides deployment guide, Docker setup, environment config]
```

**This is how development should feel**: Natural conversation that turns ideas into production-ready code through collaborative iteration. No context switching, no losing your train of thought, no starting over when you get stuck.

### üéØ **The Document Processing Revolution**

```bash
$ ./ralph "Process this AWS API documentation PDF and help me integrate S3 with my Node.js app"

[Ralph ingests 847-page PDF, creates semantic index, extracts code examples]

Ralph: I've processed the entire AWS S3 API documentation. I found 23 relevant endpoints 
for your Node.js integration. The SDK examples on pages 156-203 show the exact patterns 
you need. Let me create a complete integration...

[Ralph generates full S3 service module with error handling, retry logic, and tests]

> How do I handle large file uploads efficiently?

[Ralph recalls page 445 about multipart uploads, implements streaming solution]

> What about security best practices?

[Ralph references section 12.3 on IAM policies, generates secure configuration]
```

### üîß **Complex Multi-Step Execution**

```bash
$ ./ralph
> I need to refactor our authentication system, add rate limiting, and update the docs

Ralph: I'll handle this comprehensive refactor systematically. Let me start by auditing 
your current authentication implementation...

[Ralph analyzes entire codebase, identifies security issues]

Ralph: Found 3 critical issues in password handling. Now designing new JWT architecture 
with refresh tokens...

[Implements secure auth system with proper token rotation]

Ralph: Auth system complete. Adding Redis-backed rate limiting middleware...

[Creates rate limiting with configurable thresholds and Redis persistence]

Ralph: Rate limiting deployed. Updating API documentation with new endpoints...

[Generates comprehensive API docs with examples and security notes]

Ralph: Full refactor complete! Added tests covering all new functionality.

# Result: Complex multi-component system delivered seamlessly
```

## The Force Multiplier Effect

### üéØ **From Concept to Code in Minutes**
Stop wrestling with APIs, fighting documentation, or translating pseudocode. Ralph takes your high-level ideas and transforms them into working implementations faster than you can say "Stack Overflow."

### üß¨ **Code Evolution on Demand**
Ralph doesn't just write code - it evolves it. Refactor monoliths into microservices, migrate between frameworks, optimize algorithms, or completely rewrite systems in different languages while preserving business logic.

### üéì **Learn While You Build**
Every interaction with Ralph is a masterclass. It explains its reasoning, teaches best practices, and helps you understand not just what to code, but why. You'll absorb years of experience in weeks.

### üîÑ **Conversational Context That Never Breaks**
Ralph remembers everything from your session. Built that authentication system two hours ago? Ralph knows exactly how it works when you want to add features. Ran into an error? Ralph remembers the solution when similar issues come up. It's like pair programming with someone who has perfect memory and infinite patience.

### üß† **Vector-Powered Semantic Memory That Never Forgets**
Ralph doesn't just remember - it understands. Using advanced vector embeddings, Ralph builds semantic maps of everything: every bug you've solved, every architecture decision, every clever workaround. When you mention "authentication issues," Ralph instantly recalls not just what you said about auth, but similar security patterns, related debugging sessions, and that brilliant JWT solution from three months ago. It's like having a search engine for your entire programming experience that actually gets what you mean, not just what you typed.

### ‚ö° **Scriptable Superpowers**
One-shot mode means Ralph becomes part of your development infrastructure:
- **Pre-commit hooks** that refactor code automatically
- **CI/CD pipelines** that fix failing tests and update documentation
- **Automated code reviews** that catch security issues before humans even look
- **Documentation generators** that process PDF specs and generate living docs
- **PDF processing pipelines** that turn technical manuals into searchable knowledge
- **Vector database operations** that build semantic code indexes
- **MCP protocol integration** that brings external AI tools into Ralph's workflow
- **Memory systems** that learn from every interaction and never forget solutions
- **Shell automation** that handles complex multi-command workflows safely
- **AGENT.md support** - Define custom AI behavior with the [agent.md](https://agent.md/) specification

## Universal Compatibility

**One Binary. Every Platform. Zero Compromises.**
- Linux, Windows, macOS, FreeBSD, NetBSD, OpenBSD
- No installation, no dependencies, no containers
- Built with [Cosmopolitan Libc](https://cosmos.zip) for true portability

## Get Started in 30 Seconds

### Option 1: Download and Go
```bash
# Download the latest release
wget https://github.com/bluetongueai/ralph/releases/latest/download/ralph
chmod +x ralph

# Set your API key
export OPENAI_API_KEY=sk-your-key-here
# or
export ANTHROPIC_API_KEY=sk-ant-your-key-here

# Start building the future
./ralph "Let's build something amazing"

# Enable persistent memory and PDF processing (optional)
# Ralph will automatically create vector databases for long-term memory
```

### Option 2: Build from Source
```bash
git clone https://github.com/bluetongueai/ralph
cd ralph
make
# Coffee break while it builds...
./ralph "Hello, world"
```

## Configuration

Ralph uses environment variables and `.env` files for configuration:

```bash
# OpenAI API
OPENAI_API_KEY=sk-your-api-key
API_URL=https://api.openai.com/v1/chat/completions
MODEL=gpt-4o
CONTEXT_WINDOW=128000

# Anthropic API
ANTHROPIC_API_KEY=sk-ant-your-api-key
API_URL=https://api.anthropic.com/v1/messages
MODEL=claude-3-5-sonnet-20241022
CONTEXT_WINDOW=200000

# Local LM Studio
API_URL=http://localhost:1234/v1/chat/completions
MODEL=qwen/qwen-2.5-coder-32b
CONTEXT_WINDOW=32768

# Ollama
API_URL=http://localhost:11434/v1/chat/completions  
MODEL=llama3.3:latest
CONTEXT_WINDOW=131072
```

### Configuration Options

| Variable | Description | Default |
|----------|-------------|---------|
| `API_URL` | API endpoint URL | `https://api.openai.com/v1/chat/completions` |
| `MODEL` | Model identifier | `gpt-4o-mini` |
| `CONTEXT_WINDOW` | Model context window size | `8192` |
| `MAX_TOKENS` | Max response tokens | Auto-calculated |
| `OPENAI_API_KEY` | OpenAI API key | None |
| `ANTHROPIC_API_KEY` | Anthropic API key | None |
| `EMBEDDING_MODEL` | Embedding model for vector storage | `text-embedding-3-small` |

### Advanced Token Management

Ralph features intelligent token management that ensures models always have enough context for meaningful responses:

- **Dynamic Token Allocation**: Automatically calculates optimal token distribution based on conversation history
- **Intelligent Safety Buffers**: Calculates safety buffers dynamically based on context complexity (5% of context window + base buffer)
- **Conversation History Trimming**: Automatically trims older messages when context limits are reached, preserving recent tool interactions
- **Minimum Response Guarantee**: Always reserves at least 150 tokens for model responses
- **Accurate Token Estimation**: Uses improved token counting (3.5 chars/token) with overhead for JSON structure and tools

The system prioritizes response quality by maximizing available response tokens while ensuring the prompt fits within context limits.

## Real-World Usage Examples

### üéØ **The "I Have No Idea What I'm Doing" Scenario**
```bash
# You need to build something you've never built before
./ralph "I need to create a real-time chat app with WebSockets, but I've never used WebSockets. Walk me through building it from scratch in Node.js"

# Result: Complete tutorial + working code + deployment instructions
```

### üîç **The "Legacy Code Nightmare" Scenario**
```bash
# That 1000-line function nobody wants to touch
./ralph "This function is a monster. Break it down, explain what each part does, and refactor it into clean, testable modules" < legacy_monster.py

# Result: Detailed analysis + refactored code + migration strategy
```

### üöÄ **The "Ship It Yesterday" Scenario**
```bash
# When deadlines are breathing down your neck
./ralph "I need a complete REST API for a blog platform with authentication, CRUD operations, and pagination. Make it production-ready with proper error handling and validation."

# Result: Full implementation + tests + documentation
```

### üéì **The "Learn While Building" Scenario**
```bash
$ ./ralph
> I want to learn Rust by building a command-line tool that parses CSV files

[Ralph: "Great choice! Let me walk you through setting up a new Rust project..." 
Creates Cargo.toml, explains project structure, builds basic CSV parser]

> This is working! Now add multi-threading for large files

[Ralph: "Perfect timing to learn about Rust's concurrency model..."
Implements thread pool, explains ownership rules, shows performance comparison]

> Add proper error handling with the ? operator

[Ralph: "The ? operator is one of Rust's best features for error handling..."
Refactors code with Result types, explains error propagation, adds custom errors]

> Show me how to write comprehensive unit tests

[Ralph: "Testing in Rust is fantastic - let me show you the conventions..."
Creates test module, explains #[cfg(test)], implements property-based testing]

> How do I package this for distribution?

[Ralph: "Let's get this ready for crates.io..."
Sets up GitHub Actions, configures publishing, explains semantic versioning]

# Result: Not just working code, but deep understanding of Rust ecosystem
```

**The Learning Accelerator**: Ralph doesn't just give you fish - it teaches you to fish while helping you build an entire fishing industry.

### üß† **The "Perfect Programming Partner" Scenario**
```bash
$ ./ralph
> I'm getting a weird CORS error when calling our payment API

[Ralph: "I remember you had a similar CORS issue 3 months ago with the user service. 
You fixed it by adding specific headers in the preflight response..."
Recalls exact solution from memory]

> remember that our team decided to use JWT with 15-minute expiry for security

[Ralph: "Stored that security decision. I'll remember this for future authentication work."
Permanently stores team conventions]

> Why did we choose Redis over Memcached again?

[Ralph: "You chose Redis because you needed pub/sub for real-time notifications and 
data persistence for session storage. This was decided on March 15th when..."
Recalls exact reasoning from months ago]

> I'm refactoring the payment service. What patterns should I follow?

[Ralph: "Based on your previous work, you prefer the Repository pattern with dependency 
injection. You also always validate inputs with Joi schemas and use async/await with 
proper error boundaries. Here's how you structured the user service..."
Applies learned patterns from your past work]

> This legacy PHP code is driving me insane. How did we handle this before?

[Ralph: "I remember you dealt with similar legacy PHP code in the invoice system. 
You created a wrapper service that gradually migrated functionality while maintaining 
the existing API. Here's the exact approach..."
Recalls solutions to similar problems]

# Result: An AI partner that learns YOUR way of coding and remembers EVERYTHING
```

**The Perfect Memory**: Ralph becomes an extension of your own brain - remembering every solution, learning every pattern, and growing smarter with every interaction. It's not just AI assistance; it's AI that becomes YOU.

### üìö **The Technical Library Transformation**

```bash
$ ./ralph "Process these React documentation PDFs and help me optimize our component architecture"

[Ralph ingests 1,200 pages of React docs, Next.js guides, and performance whitepapers]

Ralph: I've indexed your entire React library. I found 47 optimization patterns across 
the documentation. Your current components violate 3 key performance principles I 
discovered on pages 234, 567, and 891. Let me show you the fixes...

[Creates optimized component architecture with lazy loading and memoization]

> remember this optimization approach for future React projects

Ralph: ‚úÖ Stored semantic memory: "React optimization architecture with lazy loading 
pattern - 40% performance improvement on large component trees"

> Three months later...
> I'm having performance issues with this Vue.js app

Ralph: I remember you solved similar performance issues with React using lazy loading 
and component memoization. The same principles apply to Vue - let me adapt that 
optimization pattern...

[Applies learned patterns from React to Vue, cross-framework knowledge transfer]
```

## Automation and Integration

### üîÑ **Git Workflow Automation**
```bash
# .git/hooks/pre-commit
#!/bin/bash
./ralph "Review this commit for potential issues and suggest improvements" < <(git diff --cached)

# .git/hooks/prepare-commit-msg  
#!/bin/bash
commit_msg=$(./ralph "Generate a commit message for: $(git diff --staged --name-only | tr '\n' ' ')")
echo "$commit_msg" > $1
```

### üèóÔ∏è **CI/CD Integration**
```yaml
# GitHub Actions
- name: AI Code Review
  run: |
    git diff origin/main..HEAD | ./ralph "Provide a thorough code review with specific suggestions"

# GitLab CI
script:
  - ./ralph "Analyze test failures and suggest fixes" < test_results.log
```

### ü§ñ **Development Workflow Automation**
```bash
# Build error assistant
make 2>&1 | ./ralph "Fix these build errors and explain what went wrong"

# Automated documentation with PDF processing
./ralph "Process the API spec PDF and generate comprehensive documentation with examples" 

# Test failure debugging
pytest --tb=short 2>&1 | ./ralph "Debug these test failures and provide fixes"

# Ralph automatically uses MCP tools as needed
./ralph "Optimize our AWS infrastructure costs"
# Ralph automatically connects to AWS MCP tools to analyze and optimize

# Advanced memory operations
./ralph "remember this regex solution for parsing email addresses - it handles edge cases the others missed"

# Vector-powered knowledge recall
./ralph "What was that database optimization technique we used for the payment service?"

# PDF-powered research
./ralph "Search the PostgreSQL documentation for best practices on connection pooling"
```

### üîå **MCP Protocol Integration**
```bash
# Ask Ralph to do something - it automatically uses the right MCP tools
./ralph "Deploy this app to production and set up monitoring"
# Ralph automatically uses AWS/Docker/monitoring MCP tools as needed

./ralph "Optimize these slow database queries"
# Ralph connects to your database through MCP and analyzes performance

./ralph "Review our recent commits for security issues" 
# Ralph uses GitHub MCP integration to analyze repository history

./ralph "Set up automated backups for our user data"
# Ralph uses cloud provider MCP tools to configure backup systems

./ralph "Migrate this SQLite data to PostgreSQL"
# Ralph uses database MCP tools to handle the migration seamlessly
```

### üéõÔ∏è **Custom AI Behavior**
Create an `AGENT.md` file following the [agent.md specification](https://agent.md/):

```markdown
# Development Assistant Agent

You are a senior software architect specializing in distributed systems.
Focus on scalability, reliability, and maintainability.

## Priorities
- Performance optimization
- Security best practices  
- Clean architecture principles
```

## Why Ralph Changes Everything

### For Individual Developers
Ralph transforms you from someone who googles "how to" into someone who just *does*. No more context switching between Stack Overflow tabs, no more deciphering cryptic error messages alone, no more getting stuck on APIs you've never used. Ralph is your 24/7 senior developer with perfect memory who never gets impatient with your questions and learns from every mistake you make together.

### For Teams
Ralph democratizes expertise across your entire team while building institutional memory that never leaves. Junior developers can tackle senior-level problems with Ralph's guidance. Senior developers can focus on architecture while Ralph handles the implementation details. When team members leave, their knowledge stays in Ralph's memory. Code reviews become collaborative learning sessions that improve the entire team's collective intelligence.

### For Companies
Ralph is the ultimate force multiplier for development velocity with permanent institutional memory. It reduces onboarding time from months to weeks, turns every developer into a polyglot programmer, and ensures critical knowledge never walks out the door when employees leave. Ralph learns from every bug fix, every architecture decision, every successful pattern - building a permanent knowledge base that makes your entire organization smarter over time.

## Universal Deployment

**Runs everywhere. Breaks nowhere.**
- Linux, Windows, macOS, FreeBSD, NetBSD, OpenBSD
- Servers, desktops, containers, CI/CD pipelines
- No runtime dependencies, no installation headaches
- One binary to rule them all

## Get Ralph Now

```bash
# The future of programming is one download away
wget https://github.com/bluetongueai/ralph/releases/latest/download/ralph
chmod +x ralph
export OPENAI_API_KEY=your-key-here
./ralph "Transform me into a 10x developer"
```

---

**Ralph: Because every programmer deserves a senior developer in their corner.**

Built with [Cosmopolitan Libc](https://github.com/jart/cosmopolitan) for true universal portability.
